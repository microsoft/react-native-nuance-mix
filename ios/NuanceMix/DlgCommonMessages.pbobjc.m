// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dlg_common_messages.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "DlgCommonMessages.pbobjc.h"
#import "Result.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(DLGBackendConnectionSettings);
GPBObjCClassDeclaration(DLGContinueAction);
GPBObjCClassDeclaration(DLGDAAction);
GPBObjCClassDeclaration(DLGDialogEvent);
GPBObjCClassDeclaration(DLGEndAction);
GPBObjCClassDeclaration(DLGEscalationAction);
GPBObjCClassDeclaration(DLGMessage);
GPBObjCClassDeclaration(DLGMessageSettings);
GPBObjCClassDeclaration(DLGMessage_Audio);
GPBObjCClassDeclaration(DLGMessage_Nlg);
GPBObjCClassDeclaration(DLGMessage_TTSParameters);
GPBObjCClassDeclaration(DLGMessage_TTSParameters_Voice);
GPBObjCClassDeclaration(DLGMessage_Visual);
GPBObjCClassDeclaration(DLGQAAction);
GPBObjCClassDeclaration(DLGRecognitionSettings);
GPBObjCClassDeclaration(DLGRecognitionSettings_CollectionSettings);
GPBObjCClassDeclaration(DLGRecognitionSettings_DtmfMapping);
GPBObjCClassDeclaration(DLGRecognitionSettings_DtmfSettings);
GPBObjCClassDeclaration(DLGRecognitionSettings_SpeechSettings);
GPBObjCClassDeclaration(DLGRequestData);
GPBObjCClassDeclaration(DLGResourceReference);
GPBObjCClassDeclaration(DLGSelectable);
GPBObjCClassDeclaration(DLGSelectable_SelectableItem);
GPBObjCClassDeclaration(DLGSelectable_SelectableItem_SelectedValue);
GPBObjCClassDeclaration(DLGUserInput);
GPBObjCClassDeclaration(DLGUserInput_Interpretation);
GPBObjCClassDeclaration(DLGView);
GPBObjCClassDeclaration(DLGVxmlConfiguration);
GPBObjCClassDeclaration(DLGVxmlResourceReference);
GPBObjCClassDeclaration(DLGVxmlResourceReference_GrammarResourceReference);
GPBObjCClassDeclaration(GPBStruct);
GPBObjCClassDeclaration(InterpretResult);

#pragma mark - DLGDlgCommonMessagesRoot

@implementation DLGDlgCommonMessagesRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - DLGDlgCommonMessagesRoot_FileDescriptor

static GPBFileDescriptor *DLGDlgCommonMessagesRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"nuance.dlg.v1.common"
                                                 objcPrefix:@"DLG"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - DLGStartRequestPayload

@implementation DLGStartRequestPayload

@dynamic hasModelRef, modelRef;
@dynamic hasData_p, data_p;
@dynamic suppressLogUserData;

typedef struct DLGStartRequestPayload__storage_ {
  uint32_t _has_storage_[1];
  DLGResourceReference *modelRef;
  GPBStruct *data_p;
} DLGStartRequestPayload__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "modelRef",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGResourceReference),
        .number = DLGStartRequestPayload_FieldNumber_ModelRef,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGStartRequestPayload__storage_, modelRef),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStruct),
        .number = DLGStartRequestPayload_FieldNumber_Data_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLGStartRequestPayload__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "suppressLogUserData",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGStartRequestPayload_FieldNumber_SuppressLogUserData,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGStartRequestPayload class]
                                     rootClass:[DLGDlgCommonMessagesRoot class]
                                          file:DLGDlgCommonMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGStartRequestPayload__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLGResourceReference

@implementation DLGResourceReference

@dynamic uri;
@dynamic type;

typedef struct DLGResourceReference__storage_ {
  uint32_t _has_storage_[1];
  DLGResourceReference_EnumResourceType type;
  NSString *uri;
} DLGResourceReference__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uri",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGResourceReference_FieldNumber_Uri,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGResourceReference__storage_, uri),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = DLGResourceReference_EnumResourceType_EnumDescriptor,
        .number = DLGResourceReference_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLGResourceReference__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGResourceReference class]
                                     rootClass:[DLGDlgCommonMessagesRoot class]
                                          file:DLGDlgCommonMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGResourceReference__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t DLGResourceReference_Type_RawValue(DLGResourceReference *message) {
  GPBDescriptor *descriptor = [DLGResourceReference descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DLGResourceReference_FieldNumber_Type];
  return GPBGetMessageRawEnumField(message, field);
}

void SetDLGResourceReference_Type_RawValue(DLGResourceReference *message, int32_t value) {
  GPBDescriptor *descriptor = [DLGResourceReference descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DLGResourceReference_FieldNumber_Type];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum DLGResourceReference_EnumResourceType

GPBEnumDescriptor *DLGResourceReference_EnumResourceType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ApplicationModel\000";
    static const int32_t values[] = {
        DLGResourceReference_EnumResourceType_ApplicationModel,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(DLGResourceReference_EnumResourceType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:DLGResourceReference_EnumResourceType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL DLGResourceReference_EnumResourceType_IsValidValue(int32_t value__) {
  switch (value__) {
    case DLGResourceReference_EnumResourceType_ApplicationModel:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - DLGStartResponsePayload

@implementation DLGStartResponsePayload

@dynamic sessionId;

typedef struct DLGStartResponsePayload__storage_ {
  uint32_t _has_storage_[1];
  NSString *sessionId;
} DLGStartResponsePayload__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sessionId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGStartResponsePayload_FieldNumber_SessionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGStartResponsePayload__storage_, sessionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGStartResponsePayload class]
                                     rootClass:[DLGDlgCommonMessagesRoot class]
                                          file:DLGDlgCommonMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGStartResponsePayload__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLGUpdateRequestPayload

@implementation DLGUpdateRequestPayload

@dynamic hasData_p, data_p;

typedef struct DLGUpdateRequestPayload__storage_ {
  uint32_t _has_storage_[1];
  GPBStruct *data_p;
} DLGUpdateRequestPayload__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "data_p",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStruct),
        .number = DLGUpdateRequestPayload_FieldNumber_Data_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGUpdateRequestPayload__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGUpdateRequestPayload class]
                                     rootClass:[DLGDlgCommonMessagesRoot class]
                                          file:DLGDlgCommonMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGUpdateRequestPayload__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLGExecuteRequestPayload

@implementation DLGExecuteRequestPayload

@dynamic hasUserInput, userInput;
@dynamic hasDialogEvent, dialogEvent;
@dynamic hasRequestedData, requestedData;

typedef struct DLGExecuteRequestPayload__storage_ {
  uint32_t _has_storage_[1];
  DLGUserInput *userInput;
  DLGDialogEvent *dialogEvent;
  DLGRequestData *requestedData;
} DLGExecuteRequestPayload__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userInput",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGUserInput),
        .number = DLGExecuteRequestPayload_FieldNumber_UserInput,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGExecuteRequestPayload__storage_, userInput),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "dialogEvent",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGDialogEvent),
        .number = DLGExecuteRequestPayload_FieldNumber_DialogEvent,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLGExecuteRequestPayload__storage_, dialogEvent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "requestedData",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGRequestData),
        .number = DLGExecuteRequestPayload_FieldNumber_RequestedData,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLGExecuteRequestPayload__storage_, requestedData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGExecuteRequestPayload class]
                                     rootClass:[DLGDlgCommonMessagesRoot class]
                                          file:DLGDlgCommonMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGExecuteRequestPayload__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLGUserInput

@implementation DLGUserInput

@dynamic inputOneOfCase;
@dynamic userText;
@dynamic interpretation;
@dynamic selectedItem;
@dynamic nluaasInterpretation;
@dynamic inputMode;

typedef struct DLGUserInput__storage_ {
  uint32_t _has_storage_[2];
  NSString *userText;
  DLGUserInput_Interpretation *interpretation;
  DLGSelectable_SelectableItem_SelectedValue *selectedItem;
  InterpretResult *nluaasInterpretation;
  NSString *inputMode;
} DLGUserInput__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userText",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGUserInput_FieldNumber_UserText,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DLGUserInput__storage_, userText),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "interpretation",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGUserInput_Interpretation),
        .number = DLGUserInput_FieldNumber_Interpretation,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DLGUserInput__storage_, interpretation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "selectedItem",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGSelectable_SelectableItem_SelectedValue),
        .number = DLGUserInput_FieldNumber_SelectedItem,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DLGUserInput__storage_, selectedItem),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nluaasInterpretation",
        .dataTypeSpecific.clazz = GPBObjCClass(InterpretResult),
        .number = DLGUserInput_FieldNumber_NluaasInterpretation,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DLGUserInput__storage_, nluaasInterpretation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "inputMode",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGUserInput_FieldNumber_InputMode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGUserInput__storage_, inputMode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGUserInput class]
                                     rootClass:[DLGDlgCommonMessagesRoot class]
                                          file:DLGDlgCommonMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGUserInput__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "input",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void DLGUserInput_ClearInputOneOfCase(DLGUserInput *message) {
  GPBDescriptor *descriptor = [DLGUserInput descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - DLGUserInput_Interpretation

@implementation DLGUserInput_Interpretation

@dynamic confidence;
@dynamic inputMode;
@dynamic utterance;
@dynamic data_p, data_p_Count;
@dynamic slotLiterals, slotLiterals_Count;
@dynamic slotFormattedLiterals, slotFormattedLiterals_Count;
@dynamic alternativeInterpretationsArray, alternativeInterpretationsArray_Count;
@dynamic slotConfidences, slotConfidences_Count;

typedef struct DLGUserInput_Interpretation__storage_ {
  uint32_t _has_storage_[1];
  float confidence;
  NSString *inputMode;
  NSString *utterance;
  NSMutableDictionary *data_p;
  NSMutableDictionary *slotLiterals;
  NSMutableArray *alternativeInterpretationsArray;
  GPBStringFloatDictionary *slotConfidences;
  NSMutableDictionary *slotFormattedLiterals;
} DLGUserInput_Interpretation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "confidence",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGUserInput_Interpretation_FieldNumber_Confidence,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGUserInput_Interpretation__storage_, confidence),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "inputMode",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGUserInput_Interpretation_FieldNumber_InputMode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLGUserInput_Interpretation__storage_, inputMode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "utterance",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGUserInput_Interpretation_FieldNumber_Utterance,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLGUserInput_Interpretation__storage_, utterance),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGUserInput_Interpretation_FieldNumber_Data_p,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLGUserInput_Interpretation__storage_, data_p),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "slotLiterals",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGUserInput_Interpretation_FieldNumber_SlotLiterals,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLGUserInput_Interpretation__storage_, slotLiterals),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "alternativeInterpretationsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGUserInput_Interpretation),
        .number = DLGUserInput_Interpretation_FieldNumber_AlternativeInterpretationsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLGUserInput_Interpretation__storage_, alternativeInterpretationsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "slotConfidences",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGUserInput_Interpretation_FieldNumber_SlotConfidences,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLGUserInput_Interpretation__storage_, slotConfidences),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "slotFormattedLiterals",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGUserInput_Interpretation_FieldNumber_SlotFormattedLiterals,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLGUserInput_Interpretation__storage_, slotFormattedLiterals),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGUserInput_Interpretation class]
                                     rootClass:[DLGDlgCommonMessagesRoot class]
                                          file:DLGDlgCommonMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGUserInput_Interpretation__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(DLGUserInput)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLGRequestData

@implementation DLGRequestData

@dynamic id_p;
@dynamic hasData_p, data_p;

typedef struct DLGRequestData__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  GPBStruct *data_p;
} DLGRequestData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGRequestData_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGRequestData__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStruct),
        .number = DLGRequestData_FieldNumber_Data_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLGRequestData__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGRequestData class]
                                     rootClass:[DLGDlgCommonMessagesRoot class]
                                          file:DLGDlgCommonMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGRequestData__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLGExecuteResponsePayload

@implementation DLGExecuteResponsePayload

@dynamic actionOneOfCase;
@dynamic messagesArray, messagesArray_Count;
@dynamic qaAction;
@dynamic daAction;
@dynamic escalationAction;
@dynamic endAction;
@dynamic continueAction;

typedef struct DLGExecuteResponsePayload__storage_ {
  uint32_t _has_storage_[2];
  NSMutableArray *messagesArray;
  DLGQAAction *qaAction;
  DLGDAAction *daAction;
  DLGEscalationAction *escalationAction;
  DLGEndAction *endAction;
  DLGContinueAction *continueAction;
} DLGExecuteResponsePayload__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "messagesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGMessage),
        .number = DLGExecuteResponsePayload_FieldNumber_MessagesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLGExecuteResponsePayload__storage_, messagesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "qaAction",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGQAAction),
        .number = DLGExecuteResponsePayload_FieldNumber_QaAction,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DLGExecuteResponsePayload__storage_, qaAction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "daAction",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGDAAction),
        .number = DLGExecuteResponsePayload_FieldNumber_DaAction,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DLGExecuteResponsePayload__storage_, daAction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "escalationAction",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGEscalationAction),
        .number = DLGExecuteResponsePayload_FieldNumber_EscalationAction,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DLGExecuteResponsePayload__storage_, escalationAction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "endAction",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGEndAction),
        .number = DLGExecuteResponsePayload_FieldNumber_EndAction,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DLGExecuteResponsePayload__storage_, endAction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "continueAction",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGContinueAction),
        .number = DLGExecuteResponsePayload_FieldNumber_ContinueAction,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DLGExecuteResponsePayload__storage_, continueAction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGExecuteResponsePayload class]
                                     rootClass:[DLGDlgCommonMessagesRoot class]
                                          file:DLGDlgCommonMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGExecuteResponsePayload__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "action",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void DLGExecuteResponsePayload_ClearActionOneOfCase(DLGExecuteResponsePayload *message) {
  GPBDescriptor *descriptor = [DLGExecuteResponsePayload descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - DLGMessage

@implementation DLGMessage

@dynamic nlgArray, nlgArray_Count;
@dynamic visualArray, visualArray_Count;
@dynamic audioArray, audioArray_Count;
@dynamic hasView, view;
@dynamic language;
@dynamic hasTtsParameters, ttsParameters;

typedef struct DLGMessage__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *nlgArray;
  NSMutableArray *visualArray;
  NSMutableArray *audioArray;
  DLGView *view;
  NSString *language;
  DLGMessage_TTSParameters *ttsParameters;
} DLGMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nlgArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGMessage_Nlg),
        .number = DLGMessage_FieldNumber_NlgArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLGMessage__storage_, nlgArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "visualArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGMessage_Visual),
        .number = DLGMessage_FieldNumber_VisualArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLGMessage__storage_, visualArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "audioArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGMessage_Audio),
        .number = DLGMessage_FieldNumber_AudioArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLGMessage__storage_, audioArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "view",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGView),
        .number = DLGMessage_FieldNumber_View,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGMessage__storage_, view),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "language",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGMessage_FieldNumber_Language,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLGMessage__storage_, language),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ttsParameters",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGMessage_TTSParameters),
        .number = DLGMessage_FieldNumber_TtsParameters,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLGMessage__storage_, ttsParameters),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGMessage class]
                                     rootClass:[DLGDlgCommonMessagesRoot class]
                                          file:DLGDlgCommonMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLGMessage_Nlg

@implementation DLGMessage_Nlg

@dynamic text;
@dynamic mask;
@dynamic bargeInDisabled;

typedef struct DLGMessage_Nlg__storage_ {
  uint32_t _has_storage_[1];
  NSString *text;
} DLGMessage_Nlg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "text",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGMessage_Nlg_FieldNumber_Text,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGMessage_Nlg__storage_, text),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mask",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGMessage_Nlg_FieldNumber_Mask,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "bargeInDisabled",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGMessage_Nlg_FieldNumber_BargeInDisabled,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGMessage_Nlg class]
                                     rootClass:[DLGDlgCommonMessagesRoot class]
                                          file:DLGDlgCommonMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGMessage_Nlg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(DLGMessage)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLGMessage_Visual

@implementation DLGMessage_Visual

@dynamic text;
@dynamic mask;
@dynamic bargeInDisabled;

typedef struct DLGMessage_Visual__storage_ {
  uint32_t _has_storage_[1];
  NSString *text;
} DLGMessage_Visual__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "text",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGMessage_Visual_FieldNumber_Text,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGMessage_Visual__storage_, text),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mask",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGMessage_Visual_FieldNumber_Mask,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "bargeInDisabled",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGMessage_Visual_FieldNumber_BargeInDisabled,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGMessage_Visual class]
                                     rootClass:[DLGDlgCommonMessagesRoot class]
                                          file:DLGDlgCommonMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGMessage_Visual__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(DLGMessage)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLGMessage_Audio

@implementation DLGMessage_Audio

@dynamic audioSrcOneOfCase;
@dynamic text;
@dynamic uri;
@dynamic mask;
@dynamic bargeInDisabled;

typedef struct DLGMessage_Audio__storage_ {
  uint32_t _has_storage_[2];
  NSString *text;
  NSString *uri;
} DLGMessage_Audio__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "text",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGMessage_Audio_FieldNumber_Text,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGMessage_Audio__storage_, text),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uri",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGMessage_Audio_FieldNumber_Uri,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DLGMessage_Audio__storage_, uri),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mask",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGMessage_Audio_FieldNumber_Mask,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "bargeInDisabled",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGMessage_Audio_FieldNumber_BargeInDisabled,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGMessage_Audio class]
                                     rootClass:[DLGDlgCommonMessagesRoot class]
                                          file:DLGDlgCommonMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGMessage_Audio__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "audioSrc",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(DLGMessage)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void DLGMessage_Audio_ClearAudioSrcOneOfCase(DLGMessage_Audio *message) {
  GPBDescriptor *descriptor = [DLGMessage_Audio descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - DLGMessage_TTSParameters

@implementation DLGMessage_TTSParameters

@dynamic hasVoice, voice;

typedef struct DLGMessage_TTSParameters__storage_ {
  uint32_t _has_storage_[1];
  DLGMessage_TTSParameters_Voice *voice;
} DLGMessage_TTSParameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "voice",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGMessage_TTSParameters_Voice),
        .number = DLGMessage_TTSParameters_FieldNumber_Voice,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGMessage_TTSParameters__storage_, voice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGMessage_TTSParameters class]
                                     rootClass:[DLGDlgCommonMessagesRoot class]
                                          file:DLGDlgCommonMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGMessage_TTSParameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(DLGMessage)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLGMessage_TTSParameters_Voice

@implementation DLGMessage_TTSParameters_Voice

@dynamic name;
@dynamic model;
@dynamic gender;
@dynamic language;

typedef struct DLGMessage_TTSParameters_Voice__storage_ {
  uint32_t _has_storage_[1];
  DLGMessage_TTSParameters_Voice_EnumGender gender;
  NSString *name;
  NSString *model;
  NSString *language;
} DLGMessage_TTSParameters_Voice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGMessage_TTSParameters_Voice_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGMessage_TTSParameters_Voice__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "model",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGMessage_TTSParameters_Voice_FieldNumber_Model,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLGMessage_TTSParameters_Voice__storage_, model),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gender",
        .dataTypeSpecific.enumDescFunc = DLGMessage_TTSParameters_Voice_EnumGender_EnumDescriptor,
        .number = DLGMessage_TTSParameters_Voice_FieldNumber_Gender,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLGMessage_TTSParameters_Voice__storage_, gender),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "language",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGMessage_TTSParameters_Voice_FieldNumber_Language,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLGMessage_TTSParameters_Voice__storage_, language),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGMessage_TTSParameters_Voice class]
                                     rootClass:[DLGDlgCommonMessagesRoot class]
                                          file:DLGDlgCommonMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGMessage_TTSParameters_Voice__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(DLGMessage_TTSParameters)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t DLGMessage_TTSParameters_Voice_Gender_RawValue(DLGMessage_TTSParameters_Voice *message) {
  GPBDescriptor *descriptor = [DLGMessage_TTSParameters_Voice descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DLGMessage_TTSParameters_Voice_FieldNumber_Gender];
  return GPBGetMessageRawEnumField(message, field);
}

void SetDLGMessage_TTSParameters_Voice_Gender_RawValue(DLGMessage_TTSParameters_Voice *message, int32_t value) {
  GPBDescriptor *descriptor = [DLGMessage_TTSParameters_Voice descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DLGMessage_TTSParameters_Voice_FieldNumber_Gender];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum DLGMessage_TTSParameters_Voice_EnumGender

GPBEnumDescriptor *DLGMessage_TTSParameters_Voice_EnumGender_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Any\000Male\000Female\000Neutral\000";
    static const int32_t values[] = {
        DLGMessage_TTSParameters_Voice_EnumGender_Any,
        DLGMessage_TTSParameters_Voice_EnumGender_Male,
        DLGMessage_TTSParameters_Voice_EnumGender_Female,
        DLGMessage_TTSParameters_Voice_EnumGender_Neutral,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(DLGMessage_TTSParameters_Voice_EnumGender)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:DLGMessage_TTSParameters_Voice_EnumGender_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL DLGMessage_TTSParameters_Voice_EnumGender_IsValidValue(int32_t value__) {
  switch (value__) {
    case DLGMessage_TTSParameters_Voice_EnumGender_Any:
    case DLGMessage_TTSParameters_Voice_EnumGender_Male:
    case DLGMessage_TTSParameters_Voice_EnumGender_Female:
    case DLGMessage_TTSParameters_Voice_EnumGender_Neutral:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - DLGView

@implementation DLGView

@dynamic id_p;
@dynamic name;

typedef struct DLGView__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  NSString *name;
} DLGView__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGView_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGView__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGView_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLGView__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGView class]
                                     rootClass:[DLGDlgCommonMessagesRoot class]
                                          file:DLGDlgCommonMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGView__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLGSelectable

@implementation DLGSelectable

@dynamic selectableItemsArray, selectableItemsArray_Count;

typedef struct DLGSelectable__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *selectableItemsArray;
} DLGSelectable__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "selectableItemsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGSelectable_SelectableItem),
        .number = DLGSelectable_FieldNumber_SelectableItemsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLGSelectable__storage_, selectableItemsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGSelectable class]
                                     rootClass:[DLGDlgCommonMessagesRoot class]
                                          file:DLGDlgCommonMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGSelectable__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLGSelectable_SelectableItem

@implementation DLGSelectable_SelectableItem

@dynamic hasValue, value;
@dynamic description_p;
@dynamic displayText;
@dynamic displayImageUri;

typedef struct DLGSelectable_SelectableItem__storage_ {
  uint32_t _has_storage_[1];
  DLGSelectable_SelectableItem_SelectedValue *value;
  NSString *description_p;
  NSString *displayText;
  NSString *displayImageUri;
} DLGSelectable_SelectableItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGSelectable_SelectableItem_SelectedValue),
        .number = DLGSelectable_SelectableItem_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGSelectable_SelectableItem__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGSelectable_SelectableItem_FieldNumber_Description_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLGSelectable_SelectableItem__storage_, description_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "displayText",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGSelectable_SelectableItem_FieldNumber_DisplayText,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLGSelectable_SelectableItem__storage_, displayText),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "displayImageUri",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGSelectable_SelectableItem_FieldNumber_DisplayImageUri,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLGSelectable_SelectableItem__storage_, displayImageUri),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGSelectable_SelectableItem class]
                                     rootClass:[DLGDlgCommonMessagesRoot class]
                                          file:DLGDlgCommonMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGSelectable_SelectableItem__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(DLGSelectable)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLGSelectable_SelectableItem_SelectedValue

@implementation DLGSelectable_SelectableItem_SelectedValue

@dynamic id_p;
@dynamic value;

typedef struct DLGSelectable_SelectableItem_SelectedValue__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  NSString *value;
} DLGSelectable_SelectableItem_SelectedValue__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGSelectable_SelectableItem_SelectedValue_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGSelectable_SelectableItem_SelectedValue__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGSelectable_SelectableItem_SelectedValue_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLGSelectable_SelectableItem_SelectedValue__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGSelectable_SelectableItem_SelectedValue class]
                                     rootClass:[DLGDlgCommonMessagesRoot class]
                                          file:DLGDlgCommonMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGSelectable_SelectableItem_SelectedValue__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(DLGSelectable_SelectableItem)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLGRecognitionSettings

@implementation DLGRecognitionSettings

@dynamic dtmfMappingsArray, dtmfMappingsArray_Count;
@dynamic hasCollectionSettings, collectionSettings;
@dynamic hasSpeechSettings, speechSettings;
@dynamic hasDtmfSettings, dtmfSettings;

typedef struct DLGRecognitionSettings__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *dtmfMappingsArray;
  DLGRecognitionSettings_CollectionSettings *collectionSettings;
  DLGRecognitionSettings_SpeechSettings *speechSettings;
  DLGRecognitionSettings_DtmfSettings *dtmfSettings;
} DLGRecognitionSettings__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dtmfMappingsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGRecognitionSettings_DtmfMapping),
        .number = DLGRecognitionSettings_FieldNumber_DtmfMappingsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLGRecognitionSettings__storage_, dtmfMappingsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "collectionSettings",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGRecognitionSettings_CollectionSettings),
        .number = DLGRecognitionSettings_FieldNumber_CollectionSettings,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGRecognitionSettings__storage_, collectionSettings),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "speechSettings",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGRecognitionSettings_SpeechSettings),
        .number = DLGRecognitionSettings_FieldNumber_SpeechSettings,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLGRecognitionSettings__storage_, speechSettings),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "dtmfSettings",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGRecognitionSettings_DtmfSettings),
        .number = DLGRecognitionSettings_FieldNumber_DtmfSettings,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLGRecognitionSettings__storage_, dtmfSettings),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGRecognitionSettings class]
                                     rootClass:[DLGDlgCommonMessagesRoot class]
                                          file:DLGDlgCommonMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGRecognitionSettings__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLGRecognitionSettings_DtmfMapping

@implementation DLGRecognitionSettings_DtmfMapping

@dynamic id_p;
@dynamic value;
@dynamic dtmfKey;

typedef struct DLGRecognitionSettings_DtmfMapping__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  NSString *value;
  NSString *dtmfKey;
} DLGRecognitionSettings_DtmfMapping__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGRecognitionSettings_DtmfMapping_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGRecognitionSettings_DtmfMapping__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGRecognitionSettings_DtmfMapping_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLGRecognitionSettings_DtmfMapping__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "dtmfKey",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGRecognitionSettings_DtmfMapping_FieldNumber_DtmfKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLGRecognitionSettings_DtmfMapping__storage_, dtmfKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGRecognitionSettings_DtmfMapping class]
                                     rootClass:[DLGDlgCommonMessagesRoot class]
                                          file:DLGDlgCommonMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGRecognitionSettings_DtmfMapping__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(DLGRecognitionSettings)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLGRecognitionSettings_CollectionSettings

@implementation DLGRecognitionSettings_CollectionSettings

@dynamic timeout;
@dynamic completeTimeout;
@dynamic incompleteTimeout;
@dynamic maxSpeechTimeout;

typedef struct DLGRecognitionSettings_CollectionSettings__storage_ {
  uint32_t _has_storage_[1];
  NSString *timeout;
  NSString *completeTimeout;
  NSString *incompleteTimeout;
  NSString *maxSpeechTimeout;
} DLGRecognitionSettings_CollectionSettings__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timeout",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGRecognitionSettings_CollectionSettings_FieldNumber_Timeout,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGRecognitionSettings_CollectionSettings__storage_, timeout),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "completeTimeout",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGRecognitionSettings_CollectionSettings_FieldNumber_CompleteTimeout,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLGRecognitionSettings_CollectionSettings__storage_, completeTimeout),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "incompleteTimeout",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGRecognitionSettings_CollectionSettings_FieldNumber_IncompleteTimeout,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLGRecognitionSettings_CollectionSettings__storage_, incompleteTimeout),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "maxSpeechTimeout",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGRecognitionSettings_CollectionSettings_FieldNumber_MaxSpeechTimeout,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLGRecognitionSettings_CollectionSettings__storage_, maxSpeechTimeout),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGRecognitionSettings_CollectionSettings class]
                                     rootClass:[DLGDlgCommonMessagesRoot class]
                                          file:DLGDlgCommonMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGRecognitionSettings_CollectionSettings__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(DLGRecognitionSettings)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLGRecognitionSettings_SpeechSettings

@implementation DLGRecognitionSettings_SpeechSettings

@dynamic sensitivity;
@dynamic bargeInType;
@dynamic speedVsAccuracy;

typedef struct DLGRecognitionSettings_SpeechSettings__storage_ {
  uint32_t _has_storage_[1];
  NSString *sensitivity;
  NSString *bargeInType;
  NSString *speedVsAccuracy;
} DLGRecognitionSettings_SpeechSettings__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sensitivity",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGRecognitionSettings_SpeechSettings_FieldNumber_Sensitivity,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGRecognitionSettings_SpeechSettings__storage_, sensitivity),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bargeInType",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGRecognitionSettings_SpeechSettings_FieldNumber_BargeInType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLGRecognitionSettings_SpeechSettings__storage_, bargeInType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "speedVsAccuracy",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGRecognitionSettings_SpeechSettings_FieldNumber_SpeedVsAccuracy,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLGRecognitionSettings_SpeechSettings__storage_, speedVsAccuracy),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGRecognitionSettings_SpeechSettings class]
                                     rootClass:[DLGDlgCommonMessagesRoot class]
                                          file:DLGDlgCommonMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGRecognitionSettings_SpeechSettings__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(DLGRecognitionSettings)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLGRecognitionSettings_DtmfSettings

@implementation DLGRecognitionSettings_DtmfSettings

@dynamic interDigitTimeout;
@dynamic termTimeout;
@dynamic termChar;

typedef struct DLGRecognitionSettings_DtmfSettings__storage_ {
  uint32_t _has_storage_[1];
  NSString *interDigitTimeout;
  NSString *termTimeout;
  NSString *termChar;
} DLGRecognitionSettings_DtmfSettings__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "interDigitTimeout",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGRecognitionSettings_DtmfSettings_FieldNumber_InterDigitTimeout,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGRecognitionSettings_DtmfSettings__storage_, interDigitTimeout),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "termTimeout",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGRecognitionSettings_DtmfSettings_FieldNumber_TermTimeout,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLGRecognitionSettings_DtmfSettings__storage_, termTimeout),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "termChar",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGRecognitionSettings_DtmfSettings_FieldNumber_TermChar,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLGRecognitionSettings_DtmfSettings__storage_, termChar),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGRecognitionSettings_DtmfSettings class]
                                     rootClass:[DLGDlgCommonMessagesRoot class]
                                          file:DLGDlgCommonMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGRecognitionSettings_DtmfSettings__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(DLGRecognitionSettings)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLGMessageSettings

@implementation DLGMessageSettings

@dynamic delay;
@dynamic minimum;

typedef struct DLGMessageSettings__storage_ {
  uint32_t _has_storage_[1];
  NSString *delay;
  NSString *minimum;
} DLGMessageSettings__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "delay",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGMessageSettings_FieldNumber_Delay,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGMessageSettings__storage_, delay),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "minimum",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGMessageSettings_FieldNumber_Minimum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLGMessageSettings__storage_, minimum),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGMessageSettings class]
                                     rootClass:[DLGDlgCommonMessagesRoot class]
                                          file:DLGDlgCommonMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGMessageSettings__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLGBackendConnectionSettings

@implementation DLGBackendConnectionSettings

@dynamic fetchTimeout;
@dynamic connectTimeout;

typedef struct DLGBackendConnectionSettings__storage_ {
  uint32_t _has_storage_[1];
  NSString *fetchTimeout;
  NSString *connectTimeout;
} DLGBackendConnectionSettings__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fetchTimeout",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGBackendConnectionSettings_FieldNumber_FetchTimeout,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGBackendConnectionSettings__storage_, fetchTimeout),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "connectTimeout",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGBackendConnectionSettings_FieldNumber_ConnectTimeout,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLGBackendConnectionSettings__storage_, connectTimeout),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGBackendConnectionSettings class]
                                     rootClass:[DLGDlgCommonMessagesRoot class]
                                          file:DLGDlgCommonMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGBackendConnectionSettings__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLGQAAction

@implementation DLGQAAction

@dynamic hasMessage, message;
@dynamic hasData_p, data_p;
@dynamic hasView, view;
@dynamic hasSelectable, selectable;
@dynamic hasRecognitionSettings, recognitionSettings;
@dynamic mask;

typedef struct DLGQAAction__storage_ {
  uint32_t _has_storage_[1];
  DLGMessage *message;
  GPBStruct *data_p;
  DLGView *view;
  DLGSelectable *selectable;
  DLGRecognitionSettings *recognitionSettings;
} DLGQAAction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "message",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGMessage),
        .number = DLGQAAction_FieldNumber_Message,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGQAAction__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStruct),
        .number = DLGQAAction_FieldNumber_Data_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLGQAAction__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "view",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGView),
        .number = DLGQAAction_FieldNumber_View,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLGQAAction__storage_, view),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "selectable",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGSelectable),
        .number = DLGQAAction_FieldNumber_Selectable,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLGQAAction__storage_, selectable),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "recognitionSettings",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGRecognitionSettings),
        .number = DLGQAAction_FieldNumber_RecognitionSettings,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DLGQAAction__storage_, recognitionSettings),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mask",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGQAAction_FieldNumber_Mask,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGQAAction class]
                                     rootClass:[DLGDlgCommonMessagesRoot class]
                                          file:DLGDlgCommonMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGQAAction__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLGDAAction

@implementation DLGDAAction

@dynamic id_p;
@dynamic hasMessage, message;
@dynamic hasView, view;
@dynamic hasData_p, data_p;
@dynamic hasMessageSettings, messageSettings;

typedef struct DLGDAAction__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  DLGMessage *message;
  DLGView *view;
  GPBStruct *data_p;
  DLGMessageSettings *messageSettings;
} DLGDAAction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGDAAction_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGDAAction__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGMessage),
        .number = DLGDAAction_FieldNumber_Message,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLGDAAction__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "view",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGView),
        .number = DLGDAAction_FieldNumber_View,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLGDAAction__storage_, view),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStruct),
        .number = DLGDAAction_FieldNumber_Data_p,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLGDAAction__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "messageSettings",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGMessageSettings),
        .number = DLGDAAction_FieldNumber_MessageSettings,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DLGDAAction__storage_, messageSettings),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGDAAction class]
                                     rootClass:[DLGDlgCommonMessagesRoot class]
                                          file:DLGDlgCommonMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGDAAction__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLGEscalationAction

@implementation DLGEscalationAction

@dynamic hasMessage, message;
@dynamic hasView, view;
@dynamic hasData_p, data_p;
@dynamic id_p;

typedef struct DLGEscalationAction__storage_ {
  uint32_t _has_storage_[1];
  DLGMessage *message;
  DLGView *view;
  GPBStruct *data_p;
  NSString *id_p;
} DLGEscalationAction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "message",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGMessage),
        .number = DLGEscalationAction_FieldNumber_Message,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGEscalationAction__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "view",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGView),
        .number = DLGEscalationAction_FieldNumber_View,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLGEscalationAction__storage_, view),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStruct),
        .number = DLGEscalationAction_FieldNumber_Data_p,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLGEscalationAction__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGEscalationAction_FieldNumber_Id_p,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLGEscalationAction__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGEscalationAction class]
                                     rootClass:[DLGDlgCommonMessagesRoot class]
                                          file:DLGDlgCommonMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGEscalationAction__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLGEndAction

@implementation DLGEndAction

@dynamic hasData_p, data_p;
@dynamic id_p;

typedef struct DLGEndAction__storage_ {
  uint32_t _has_storage_[1];
  GPBStruct *data_p;
  NSString *id_p;
} DLGEndAction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "data_p",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStruct),
        .number = DLGEndAction_FieldNumber_Data_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGEndAction__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGEndAction_FieldNumber_Id_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLGEndAction__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGEndAction class]
                                     rootClass:[DLGDlgCommonMessagesRoot class]
                                          file:DLGDlgCommonMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGEndAction__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLGContinueAction

@implementation DLGContinueAction

@dynamic hasMessage, message;
@dynamic hasView, view;
@dynamic hasData_p, data_p;
@dynamic id_p;
@dynamic hasMessageSettings, messageSettings;
@dynamic hasBackendConnectionSettings, backendConnectionSettings;

typedef struct DLGContinueAction__storage_ {
  uint32_t _has_storage_[1];
  DLGMessage *message;
  DLGView *view;
  GPBStruct *data_p;
  NSString *id_p;
  DLGMessageSettings *messageSettings;
  DLGBackendConnectionSettings *backendConnectionSettings;
} DLGContinueAction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "message",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGMessage),
        .number = DLGContinueAction_FieldNumber_Message,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGContinueAction__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "view",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGView),
        .number = DLGContinueAction_FieldNumber_View,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLGContinueAction__storage_, view),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStruct),
        .number = DLGContinueAction_FieldNumber_Data_p,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLGContinueAction__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGContinueAction_FieldNumber_Id_p,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLGContinueAction__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "messageSettings",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGMessageSettings),
        .number = DLGContinueAction_FieldNumber_MessageSettings,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DLGContinueAction__storage_, messageSettings),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "backendConnectionSettings",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGBackendConnectionSettings),
        .number = DLGContinueAction_FieldNumber_BackendConnectionSettings,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DLGContinueAction__storage_, backendConnectionSettings),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGContinueAction class]
                                     rootClass:[DLGDlgCommonMessagesRoot class]
                                          file:DLGDlgCommonMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGContinueAction__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLGVxmlConfiguration

@implementation DLGVxmlConfiguration

@dynamic resourcesArray, resourcesArray_Count;
@dynamic properties, properties_Count;

typedef struct DLGVxmlConfiguration__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *resourcesArray;
  NSMutableDictionary *properties;
} DLGVxmlConfiguration__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "resourcesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGVxmlResourceReference),
        .number = DLGVxmlConfiguration_FieldNumber_ResourcesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLGVxmlConfiguration__storage_, resourcesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "properties",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGVxmlConfiguration_FieldNumber_Properties,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLGVxmlConfiguration__storage_, properties),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGVxmlConfiguration class]
                                     rootClass:[DLGDlgCommonMessagesRoot class]
                                          file:DLGDlgCommonMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGVxmlConfiguration__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLGVxmlResourceReference

@implementation DLGVxmlResourceReference

@dynamic resourceUnionOneOfCase;
@dynamic grammarReference;
@dynamic wordsetJson;

typedef struct DLGVxmlResourceReference__storage_ {
  uint32_t _has_storage_[2];
  DLGVxmlResourceReference_GrammarResourceReference *grammarReference;
  NSString *wordsetJson;
} DLGVxmlResourceReference__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "grammarReference",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGVxmlResourceReference_GrammarResourceReference),
        .number = DLGVxmlResourceReference_FieldNumber_GrammarReference,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DLGVxmlResourceReference__storage_, grammarReference),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "wordsetJson",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGVxmlResourceReference_FieldNumber_WordsetJson,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DLGVxmlResourceReference__storage_, wordsetJson),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGVxmlResourceReference class]
                                     rootClass:[DLGDlgCommonMessagesRoot class]
                                          file:DLGDlgCommonMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGVxmlResourceReference__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "resourceUnion",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void DLGVxmlResourceReference_ClearResourceUnionOneOfCase(DLGVxmlResourceReference *message) {
  GPBDescriptor *descriptor = [DLGVxmlResourceReference descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - DLGVxmlResourceReference_GrammarResourceReference

@implementation DLGVxmlResourceReference_GrammarResourceReference

@dynamic uri;
@dynamic type;

typedef struct DLGVxmlResourceReference_GrammarResourceReference__storage_ {
  uint32_t _has_storage_[1];
  DLGVxmlResourceReference_GrammarResourceReference_EnumResourceType type;
  NSString *uri;
} DLGVxmlResourceReference_GrammarResourceReference__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uri",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGVxmlResourceReference_GrammarResourceReference_FieldNumber_Uri,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGVxmlResourceReference_GrammarResourceReference__storage_, uri),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = DLGVxmlResourceReference_GrammarResourceReference_EnumResourceType_EnumDescriptor,
        .number = DLGVxmlResourceReference_GrammarResourceReference_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLGVxmlResourceReference_GrammarResourceReference__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGVxmlResourceReference_GrammarResourceReference class]
                                     rootClass:[DLGDlgCommonMessagesRoot class]
                                          file:DLGDlgCommonMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGVxmlResourceReference_GrammarResourceReference__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(DLGVxmlResourceReference)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t DLGVxmlResourceReference_GrammarResourceReference_Type_RawValue(DLGVxmlResourceReference_GrammarResourceReference *message) {
  GPBDescriptor *descriptor = [DLGVxmlResourceReference_GrammarResourceReference descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DLGVxmlResourceReference_GrammarResourceReference_FieldNumber_Type];
  return GPBGetMessageRawEnumField(message, field);
}

void SetDLGVxmlResourceReference_GrammarResourceReference_Type_RawValue(DLGVxmlResourceReference_GrammarResourceReference *message, int32_t value) {
  GPBDescriptor *descriptor = [DLGVxmlResourceReference_GrammarResourceReference descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DLGVxmlResourceReference_GrammarResourceReference_FieldNumber_Type];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum DLGVxmlResourceReference_GrammarResourceReference_EnumResourceType

GPBEnumDescriptor *DLGVxmlResourceReference_GrammarResourceReference_EnumResourceType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "SemanticModel\000SpeechGrammar\000DtmfGrammar\000"
        "AsrDlm\000";
    static const int32_t values[] = {
        DLGVxmlResourceReference_GrammarResourceReference_EnumResourceType_SemanticModel,
        DLGVxmlResourceReference_GrammarResourceReference_EnumResourceType_SpeechGrammar,
        DLGVxmlResourceReference_GrammarResourceReference_EnumResourceType_DtmfGrammar,
        DLGVxmlResourceReference_GrammarResourceReference_EnumResourceType_AsrDlm,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(DLGVxmlResourceReference_GrammarResourceReference_EnumResourceType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:DLGVxmlResourceReference_GrammarResourceReference_EnumResourceType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL DLGVxmlResourceReference_GrammarResourceReference_EnumResourceType_IsValidValue(int32_t value__) {
  switch (value__) {
    case DLGVxmlResourceReference_GrammarResourceReference_EnumResourceType_SemanticModel:
    case DLGVxmlResourceReference_GrammarResourceReference_EnumResourceType_SpeechGrammar:
    case DLGVxmlResourceReference_GrammarResourceReference_EnumResourceType_DtmfGrammar:
    case DLGVxmlResourceReference_GrammarResourceReference_EnumResourceType_AsrDlm:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - DLGDialogEvent

@implementation DLGDialogEvent

@dynamic type;
@dynamic message;
@dynamic eventName;

typedef struct DLGDialogEvent__storage_ {
  uint32_t _has_storage_[1];
  DLGDialogEvent_EventType type;
  NSString *message;
  NSString *eventName;
} DLGDialogEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = DLGDialogEvent_EventType_EnumDescriptor,
        .number = DLGDialogEvent_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGDialogEvent__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGDialogEvent_FieldNumber_Message,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLGDialogEvent__storage_, message),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "eventName",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGDialogEvent_FieldNumber_EventName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLGDialogEvent__storage_, eventName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGDialogEvent class]
                                     rootClass:[DLGDlgCommonMessagesRoot class]
                                          file:DLGDlgCommonMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGDialogEvent__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t DLGDialogEvent_Type_RawValue(DLGDialogEvent *message) {
  GPBDescriptor *descriptor = [DLGDialogEvent descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DLGDialogEvent_FieldNumber_Type];
  return GPBGetMessageRawEnumField(message, field);
}

void SetDLGDialogEvent_Type_RawValue(DLGDialogEvent *message, int32_t value) {
  GPBDescriptor *descriptor = [DLGDialogEvent descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DLGDialogEvent_FieldNumber_Type];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum DLGDialogEvent_EventType

GPBEnumDescriptor *DLGDialogEvent_EventType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Success\000Error\000NoInput\000NoMatch\000Hangup\000Cus"
        "tom\000";
    static const int32_t values[] = {
        DLGDialogEvent_EventType_Success,
        DLGDialogEvent_EventType_Error,
        DLGDialogEvent_EventType_NoInput,
        DLGDialogEvent_EventType_NoMatch,
        DLGDialogEvent_EventType_Hangup,
        DLGDialogEvent_EventType_Custom,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(DLGDialogEvent_EventType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:DLGDialogEvent_EventType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL DLGDialogEvent_EventType_IsValidValue(int32_t value__) {
  switch (value__) {
    case DLGDialogEvent_EventType_Success:
    case DLGDialogEvent_EventType_Error:
    case DLGDialogEvent_EventType_NoInput:
    case DLGDialogEvent_EventType_NoMatch:
    case DLGDialogEvent_EventType_Hangup:
    case DLGDialogEvent_EventType_Custom:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - DLGSelector

@implementation DLGSelector

@dynamic channel;
@dynamic language;
@dynamic library;

typedef struct DLGSelector__storage_ {
  uint32_t _has_storage_[1];
  NSString *channel;
  NSString *language;
  NSString *library;
} DLGSelector__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channel",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGSelector_FieldNumber_Channel,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGSelector__storage_, channel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "language",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGSelector_FieldNumber_Language,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLGSelector__storage_, language),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "library",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGSelector_FieldNumber_Library,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLGSelector__storage_, library),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGSelector class]
                                     rootClass:[DLGDlgCommonMessagesRoot class]
                                          file:DLGDlgCommonMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGSelector__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
