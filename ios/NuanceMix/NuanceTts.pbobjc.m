// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: nuance_tts.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "NuanceTts.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(TTSALaw);
GPBObjCClassDeclaration(TTSAudioFormat);
GPBObjCClassDeclaration(TTSAudioParameters);
GPBObjCClassDeclaration(TTSControlCode);
GPBObjCClassDeclaration(TTSDownloadParameters);
GPBObjCClassDeclaration(TTSEvent);
GPBObjCClassDeclaration(TTSEventParameters);
GPBObjCClassDeclaration(TTSEvents);
GPBObjCClassDeclaration(TTSInput);
GPBObjCClassDeclaration(TTSLanguageIdentificationParameters);
GPBObjCClassDeclaration(TTSOggOpus);
GPBObjCClassDeclaration(TTSOpus);
GPBObjCClassDeclaration(TTSPCM);
GPBObjCClassDeclaration(TTSSSML);
GPBObjCClassDeclaration(TTSStatus);
GPBObjCClassDeclaration(TTSSynthesisRequest);
GPBObjCClassDeclaration(TTSSynthesisResource);
GPBObjCClassDeclaration(TTSText);
GPBObjCClassDeclaration(TTSToken);
GPBObjCClassDeclaration(TTSTokenizedSequence);
GPBObjCClassDeclaration(TTSULaw);
GPBObjCClassDeclaration(TTSVoice);

#pragma mark - TTSNuanceTtsRoot

@implementation TTSNuanceTtsRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - TTSNuanceTtsRoot_FileDescriptor

static GPBFileDescriptor *TTSNuanceTtsRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"nuance.tts.v1"
                                                 objcPrefix:@"TTS"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum TTSEnumAgeGroup

GPBEnumDescriptor *TTSEnumAgeGroup_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Adult\000Child\000";
    static const int32_t values[] = {
        TTSEnumAgeGroup_Adult,
        TTSEnumAgeGroup_Child,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(TTSEnumAgeGroup)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:TTSEnumAgeGroup_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL TTSEnumAgeGroup_IsValidValue(int32_t value__) {
  switch (value__) {
    case TTSEnumAgeGroup_Adult:
    case TTSEnumAgeGroup_Child:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum TTSEnumGender

GPBEnumDescriptor *TTSEnumGender_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Any\000Male\000Female\000Neutral\000";
    static const int32_t values[] = {
        TTSEnumGender_Any,
        TTSEnumGender_Male,
        TTSEnumGender_Female,
        TTSEnumGender_Neutral,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(TTSEnumGender)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:TTSEnumGender_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL TTSEnumGender_IsValidValue(int32_t value__) {
  switch (value__) {
    case TTSEnumGender_Any:
    case TTSEnumGender_Male:
    case TTSEnumGender_Female:
    case TTSEnumGender_Neutral:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum TTSEnumVariableBitrate

GPBEnumDescriptor *TTSEnumVariableBitrate_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "VariableBitrateOn\000VariableBitrateOff\000Var"
        "iableBitrateConstrained\000";
    static const int32_t values[] = {
        TTSEnumVariableBitrate_VariableBitrateOn,
        TTSEnumVariableBitrate_VariableBitrateOff,
        TTSEnumVariableBitrate_VariableBitrateConstrained,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(TTSEnumVariableBitrate)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:TTSEnumVariableBitrate_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL TTSEnumVariableBitrate_IsValidValue(int32_t value__) {
  switch (value__) {
    case TTSEnumVariableBitrate_VariableBitrateOn:
    case TTSEnumVariableBitrate_VariableBitrateOff:
    case TTSEnumVariableBitrate_VariableBitrateConstrained:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum TTSEnumResourceType

GPBEnumDescriptor *TTSEnumResourceType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "UserDictionary\000TextUserRuleset\000BinaryUse"
        "rRuleset\000ActivepromptDb\000ActivepromptDbAu"
        "to\000SystemDictionary\000";
    static const int32_t values[] = {
        TTSEnumResourceType_UserDictionary,
        TTSEnumResourceType_TextUserRuleset,
        TTSEnumResourceType_BinaryUserRuleset,
        TTSEnumResourceType_ActivepromptDb,
        TTSEnumResourceType_ActivepromptDbAuto,
        TTSEnumResourceType_SystemDictionary,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(TTSEnumResourceType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:TTSEnumResourceType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL TTSEnumResourceType_IsValidValue(int32_t value__) {
  switch (value__) {
    case TTSEnumResourceType_UserDictionary:
    case TTSEnumResourceType_TextUserRuleset:
    case TTSEnumResourceType_BinaryUserRuleset:
    case TTSEnumResourceType_ActivepromptDb:
    case TTSEnumResourceType_ActivepromptDbAuto:
    case TTSEnumResourceType_SystemDictionary:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum TTSEnumSSMLValidationMode

GPBEnumDescriptor *TTSEnumSSMLValidationMode_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Strict\000Warn\000None\000";
    static const int32_t values[] = {
        TTSEnumSSMLValidationMode_Strict,
        TTSEnumSSMLValidationMode_Warn,
        TTSEnumSSMLValidationMode_None,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(TTSEnumSSMLValidationMode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:TTSEnumSSMLValidationMode_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL TTSEnumSSMLValidationMode_IsValidValue(int32_t value__) {
  switch (value__) {
    case TTSEnumSSMLValidationMode_Strict:
    case TTSEnumSSMLValidationMode_Warn:
    case TTSEnumSSMLValidationMode_None:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - TTSGetVoicesRequest

@implementation TTSGetVoicesRequest

@dynamic hasVoice, voice;

typedef struct TTSGetVoicesRequest__storage_ {
  uint32_t _has_storage_[1];
  TTSVoice *voice;
} TTSGetVoicesRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "voice",
        .dataTypeSpecific.clazz = GPBObjCClass(TTSVoice),
        .number = TTSGetVoicesRequest_FieldNumber_Voice,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TTSGetVoicesRequest__storage_, voice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTSGetVoicesRequest class]
                                     rootClass:[TTSNuanceTtsRoot class]
                                          file:TTSNuanceTtsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTSGetVoicesRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTSGetVoicesResponse

@implementation TTSGetVoicesResponse

@dynamic voicesArray, voicesArray_Count;

typedef struct TTSGetVoicesResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *voicesArray;
} TTSGetVoicesResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "voicesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(TTSVoice),
        .number = TTSGetVoicesResponse_FieldNumber_VoicesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TTSGetVoicesResponse__storage_, voicesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTSGetVoicesResponse class]
                                     rootClass:[TTSNuanceTtsRoot class]
                                          file:TTSNuanceTtsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTSGetVoicesResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTSSynthesisRequest

@implementation TTSSynthesisRequest

@dynamic hasVoice, voice;
@dynamic hasAudioParams, audioParams;
@dynamic hasInput, input;
@dynamic hasEventParams, eventParams;
@dynamic clientData, clientData_Count;
@dynamic userId;

typedef struct TTSSynthesisRequest__storage_ {
  uint32_t _has_storage_[1];
  TTSVoice *voice;
  TTSAudioParameters *audioParams;
  TTSInput *input;
  TTSEventParameters *eventParams;
  NSMutableDictionary *clientData;
  NSString *userId;
} TTSSynthesisRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "voice",
        .dataTypeSpecific.clazz = GPBObjCClass(TTSVoice),
        .number = TTSSynthesisRequest_FieldNumber_Voice,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TTSSynthesisRequest__storage_, voice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "audioParams",
        .dataTypeSpecific.clazz = GPBObjCClass(TTSAudioParameters),
        .number = TTSSynthesisRequest_FieldNumber_AudioParams,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TTSSynthesisRequest__storage_, audioParams),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "input",
        .dataTypeSpecific.clazz = GPBObjCClass(TTSInput),
        .number = TTSSynthesisRequest_FieldNumber_Input,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TTSSynthesisRequest__storage_, input),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "eventParams",
        .dataTypeSpecific.clazz = GPBObjCClass(TTSEventParameters),
        .number = TTSSynthesisRequest_FieldNumber_EventParams,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TTSSynthesisRequest__storage_, eventParams),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "clientData",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSSynthesisRequest_FieldNumber_ClientData,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TTSSynthesisRequest__storage_, clientData),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSSynthesisRequest_FieldNumber_UserId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(TTSSynthesisRequest__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTSSynthesisRequest class]
                                     rootClass:[TTSNuanceTtsRoot class]
                                          file:TTSNuanceTtsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTSSynthesisRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTSVoice

@implementation TTSVoice

@dynamic name;
@dynamic model;
@dynamic language;
@dynamic ageGroup;
@dynamic gender;
@dynamic sampleRateHz;
@dynamic languageTlw;
@dynamic restricted;
@dynamic version;
@dynamic foreignLanguagesArray, foreignLanguagesArray_Count;

typedef struct TTSVoice__storage_ {
  uint32_t _has_storage_[1];
  TTSEnumAgeGroup ageGroup;
  TTSEnumGender gender;
  uint32_t sampleRateHz;
  NSString *name;
  NSString *model;
  NSString *language;
  NSString *languageTlw;
  NSString *version;
  NSMutableArray *foreignLanguagesArray;
} TTSVoice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSVoice_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TTSVoice__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "model",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSVoice_FieldNumber_Model,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TTSVoice__storage_, model),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "language",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSVoice_FieldNumber_Language,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TTSVoice__storage_, language),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ageGroup",
        .dataTypeSpecific.enumDescFunc = TTSEnumAgeGroup_EnumDescriptor,
        .number = TTSVoice_FieldNumber_AgeGroup,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TTSVoice__storage_, ageGroup),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "gender",
        .dataTypeSpecific.enumDescFunc = TTSEnumGender_EnumDescriptor,
        .number = TTSVoice_FieldNumber_Gender,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(TTSVoice__storage_, gender),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "sampleRateHz",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSVoice_FieldNumber_SampleRateHz,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(TTSVoice__storage_, sampleRateHz),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "languageTlw",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSVoice_FieldNumber_LanguageTlw,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(TTSVoice__storage_, languageTlw),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "restricted",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSVoice_FieldNumber_Restricted,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "version",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSVoice_FieldNumber_Version,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(TTSVoice__storage_, version),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "foreignLanguagesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSVoice_FieldNumber_ForeignLanguagesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TTSVoice__storage_, foreignLanguagesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTSVoice class]
                                     rootClass:[TTSNuanceTtsRoot class]
                                          file:TTSNuanceTtsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTSVoice__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t TTSVoice_AgeGroup_RawValue(TTSVoice *message) {
  GPBDescriptor *descriptor = [TTSVoice descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TTSVoice_FieldNumber_AgeGroup];
  return GPBGetMessageRawEnumField(message, field);
}

void SetTTSVoice_AgeGroup_RawValue(TTSVoice *message, int32_t value) {
  GPBDescriptor *descriptor = [TTSVoice descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TTSVoice_FieldNumber_AgeGroup];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t TTSVoice_Gender_RawValue(TTSVoice *message) {
  GPBDescriptor *descriptor = [TTSVoice descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TTSVoice_FieldNumber_Gender];
  return GPBGetMessageRawEnumField(message, field);
}

void SetTTSVoice_Gender_RawValue(TTSVoice *message, int32_t value) {
  GPBDescriptor *descriptor = [TTSVoice descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TTSVoice_FieldNumber_Gender];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - TTSAudioParameters

@implementation TTSAudioParameters

@dynamic hasAudioFormat, audioFormat;
@dynamic volumePercentage;
@dynamic speakingRateFactor;
@dynamic audioChunkDurationMs;
@dynamic targetAudioLengthMs;
@dynamic disableEarlyEmission;

typedef struct TTSAudioParameters__storage_ {
  uint32_t _has_storage_[1];
  uint32_t volumePercentage;
  float speakingRateFactor;
  uint32_t audioChunkDurationMs;
  uint32_t targetAudioLengthMs;
  TTSAudioFormat *audioFormat;
} TTSAudioParameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "audioFormat",
        .dataTypeSpecific.clazz = GPBObjCClass(TTSAudioFormat),
        .number = TTSAudioParameters_FieldNumber_AudioFormat,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TTSAudioParameters__storage_, audioFormat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "volumePercentage",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSAudioParameters_FieldNumber_VolumePercentage,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TTSAudioParameters__storage_, volumePercentage),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "speakingRateFactor",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSAudioParameters_FieldNumber_SpeakingRateFactor,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TTSAudioParameters__storage_, speakingRateFactor),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "audioChunkDurationMs",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSAudioParameters_FieldNumber_AudioChunkDurationMs,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TTSAudioParameters__storage_, audioChunkDurationMs),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "targetAudioLengthMs",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSAudioParameters_FieldNumber_TargetAudioLengthMs,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(TTSAudioParameters__storage_, targetAudioLengthMs),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "disableEarlyEmission",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSAudioParameters_FieldNumber_DisableEarlyEmission,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTSAudioParameters class]
                                     rootClass:[TTSNuanceTtsRoot class]
                                          file:TTSNuanceTtsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTSAudioParameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTSAudioFormat

@implementation TTSAudioFormat

@dynamic audioFormatOneOfCase;
@dynamic pcm;
@dynamic alaw;
@dynamic ulaw;
@dynamic oggOpus;
@dynamic opus;

typedef struct TTSAudioFormat__storage_ {
  uint32_t _has_storage_[2];
  TTSPCM *pcm;
  TTSALaw *alaw;
  TTSULaw *ulaw;
  TTSOggOpus *oggOpus;
  TTSOpus *opus;
} TTSAudioFormat__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pcm",
        .dataTypeSpecific.clazz = GPBObjCClass(TTSPCM),
        .number = TTSAudioFormat_FieldNumber_Pcm,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(TTSAudioFormat__storage_, pcm),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "alaw",
        .dataTypeSpecific.clazz = GPBObjCClass(TTSALaw),
        .number = TTSAudioFormat_FieldNumber_Alaw,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(TTSAudioFormat__storage_, alaw),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ulaw",
        .dataTypeSpecific.clazz = GPBObjCClass(TTSULaw),
        .number = TTSAudioFormat_FieldNumber_Ulaw,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(TTSAudioFormat__storage_, ulaw),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "oggOpus",
        .dataTypeSpecific.clazz = GPBObjCClass(TTSOggOpus),
        .number = TTSAudioFormat_FieldNumber_OggOpus,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(TTSAudioFormat__storage_, oggOpus),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "opus",
        .dataTypeSpecific.clazz = GPBObjCClass(TTSOpus),
        .number = TTSAudioFormat_FieldNumber_Opus,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(TTSAudioFormat__storage_, opus),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTSAudioFormat class]
                                     rootClass:[TTSNuanceTtsRoot class]
                                          file:TTSNuanceTtsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTSAudioFormat__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "audioFormat",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void TTSAudioFormat_ClearAudioFormatOneOfCase(TTSAudioFormat *message) {
  GPBDescriptor *descriptor = [TTSAudioFormat descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - TTSPCM

@implementation TTSPCM

@dynamic sampleRateHz;

typedef struct TTSPCM__storage_ {
  uint32_t _has_storage_[1];
  uint32_t sampleRateHz;
} TTSPCM__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sampleRateHz",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSPCM_FieldNumber_SampleRateHz,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TTSPCM__storage_, sampleRateHz),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTSPCM class]
                                     rootClass:[TTSNuanceTtsRoot class]
                                          file:TTSNuanceTtsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTSPCM__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTSALaw

@implementation TTSALaw


typedef struct TTSALaw__storage_ {
  uint32_t _has_storage_[1];
} TTSALaw__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTSALaw class]
                                     rootClass:[TTSNuanceTtsRoot class]
                                          file:TTSNuanceTtsRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(TTSALaw__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTSULaw

@implementation TTSULaw


typedef struct TTSULaw__storage_ {
  uint32_t _has_storage_[1];
} TTSULaw__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTSULaw class]
                                     rootClass:[TTSNuanceTtsRoot class]
                                          file:TTSNuanceTtsRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(TTSULaw__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTSOpus

@implementation TTSOpus

@dynamic sampleRateHz;
@dynamic bitRateBps;
@dynamic maxFrameDurationMs;
@dynamic complexity;
@dynamic vbr;

typedef struct TTSOpus__storage_ {
  uint32_t _has_storage_[1];
  uint32_t sampleRateHz;
  uint32_t bitRateBps;
  float maxFrameDurationMs;
  uint32_t complexity;
  TTSEnumVariableBitrate vbr;
} TTSOpus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sampleRateHz",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSOpus_FieldNumber_SampleRateHz,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TTSOpus__storage_, sampleRateHz),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "bitRateBps",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSOpus_FieldNumber_BitRateBps,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TTSOpus__storage_, bitRateBps),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "maxFrameDurationMs",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSOpus_FieldNumber_MaxFrameDurationMs,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TTSOpus__storage_, maxFrameDurationMs),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "complexity",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSOpus_FieldNumber_Complexity,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TTSOpus__storage_, complexity),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "vbr",
        .dataTypeSpecific.enumDescFunc = TTSEnumVariableBitrate_EnumDescriptor,
        .number = TTSOpus_FieldNumber_Vbr,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(TTSOpus__storage_, vbr),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTSOpus class]
                                     rootClass:[TTSNuanceTtsRoot class]
                                          file:TTSNuanceTtsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTSOpus__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t TTSOpus_Vbr_RawValue(TTSOpus *message) {
  GPBDescriptor *descriptor = [TTSOpus descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TTSOpus_FieldNumber_Vbr];
  return GPBGetMessageRawEnumField(message, field);
}

void SetTTSOpus_Vbr_RawValue(TTSOpus *message, int32_t value) {
  GPBDescriptor *descriptor = [TTSOpus descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TTSOpus_FieldNumber_Vbr];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - TTSOggOpus

@implementation TTSOggOpus

@dynamic sampleRateHz;
@dynamic bitRateBps;
@dynamic maxFrameDurationMs;
@dynamic complexity;
@dynamic vbr;

typedef struct TTSOggOpus__storage_ {
  uint32_t _has_storage_[1];
  uint32_t sampleRateHz;
  uint32_t bitRateBps;
  float maxFrameDurationMs;
  uint32_t complexity;
  TTSEnumVariableBitrate vbr;
} TTSOggOpus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sampleRateHz",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSOggOpus_FieldNumber_SampleRateHz,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TTSOggOpus__storage_, sampleRateHz),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "bitRateBps",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSOggOpus_FieldNumber_BitRateBps,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TTSOggOpus__storage_, bitRateBps),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "maxFrameDurationMs",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSOggOpus_FieldNumber_MaxFrameDurationMs,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TTSOggOpus__storage_, maxFrameDurationMs),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "complexity",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSOggOpus_FieldNumber_Complexity,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TTSOggOpus__storage_, complexity),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "vbr",
        .dataTypeSpecific.enumDescFunc = TTSEnumVariableBitrate_EnumDescriptor,
        .number = TTSOggOpus_FieldNumber_Vbr,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(TTSOggOpus__storage_, vbr),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTSOggOpus class]
                                     rootClass:[TTSNuanceTtsRoot class]
                                          file:TTSNuanceTtsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTSOggOpus__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t TTSOggOpus_Vbr_RawValue(TTSOggOpus *message) {
  GPBDescriptor *descriptor = [TTSOggOpus descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TTSOggOpus_FieldNumber_Vbr];
  return GPBGetMessageRawEnumField(message, field);
}

void SetTTSOggOpus_Vbr_RawValue(TTSOggOpus *message, int32_t value) {
  GPBDescriptor *descriptor = [TTSOggOpus descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TTSOggOpus_FieldNumber_Vbr];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - TTSInput

@implementation TTSInput

@dynamic inputDataOneOfCase;
@dynamic text;
@dynamic ssml;
@dynamic tokenizedSequence;
@dynamic resourcesArray, resourcesArray_Count;
@dynamic hasLidParams, lidParams;
@dynamic hasDownloadParams, downloadParams;

typedef struct TTSInput__storage_ {
  uint32_t _has_storage_[2];
  TTSText *text;
  TTSSSML *ssml;
  TTSTokenizedSequence *tokenizedSequence;
  NSMutableArray *resourcesArray;
  TTSLanguageIdentificationParameters *lidParams;
  TTSDownloadParameters *downloadParams;
} TTSInput__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "text",
        .dataTypeSpecific.clazz = GPBObjCClass(TTSText),
        .number = TTSInput_FieldNumber_Text,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(TTSInput__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ssml",
        .dataTypeSpecific.clazz = GPBObjCClass(TTSSSML),
        .number = TTSInput_FieldNumber_Ssml,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(TTSInput__storage_, ssml),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tokenizedSequence",
        .dataTypeSpecific.clazz = GPBObjCClass(TTSTokenizedSequence),
        .number = TTSInput_FieldNumber_TokenizedSequence,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(TTSInput__storage_, tokenizedSequence),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "resourcesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(TTSSynthesisResource),
        .number = TTSInput_FieldNumber_ResourcesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TTSInput__storage_, resourcesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lidParams",
        .dataTypeSpecific.clazz = GPBObjCClass(TTSLanguageIdentificationParameters),
        .number = TTSInput_FieldNumber_LidParams,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TTSInput__storage_, lidParams),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "downloadParams",
        .dataTypeSpecific.clazz = GPBObjCClass(TTSDownloadParameters),
        .number = TTSInput_FieldNumber_DownloadParams,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TTSInput__storage_, downloadParams),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTSInput class]
                                     rootClass:[TTSNuanceTtsRoot class]
                                          file:TTSNuanceTtsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTSInput__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "inputData",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void TTSInput_ClearInputDataOneOfCase(TTSInput *message) {
  GPBDescriptor *descriptor = [TTSInput descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - TTSText

@implementation TTSText

@dynamic textDataOneOfCase;
@dynamic text;
@dynamic uri;

typedef struct TTSText__storage_ {
  uint32_t _has_storage_[2];
  NSString *text;
  NSString *uri;
} TTSText__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "text",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSText_FieldNumber_Text,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(TTSText__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uri",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSText_FieldNumber_Uri,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(TTSText__storage_, uri),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTSText class]
                                     rootClass:[TTSNuanceTtsRoot class]
                                          file:TTSNuanceTtsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTSText__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "textData",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void TTSText_ClearTextDataOneOfCase(TTSText *message) {
  GPBDescriptor *descriptor = [TTSText descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - TTSSSML

@implementation TTSSSML

@dynamic ssmlDataOneOfCase;
@dynamic text;
@dynamic uri;
@dynamic ssmlValidationMode;

typedef struct TTSSSML__storage_ {
  uint32_t _has_storage_[2];
  TTSEnumSSMLValidationMode ssmlValidationMode;
  NSString *text;
  NSString *uri;
} TTSSSML__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "text",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSSSML_FieldNumber_Text,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(TTSSSML__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uri",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSSSML_FieldNumber_Uri,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(TTSSSML__storage_, uri),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ssmlValidationMode",
        .dataTypeSpecific.enumDescFunc = TTSEnumSSMLValidationMode_EnumDescriptor,
        .number = TTSSSML_FieldNumber_SsmlValidationMode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TTSSSML__storage_, ssmlValidationMode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTSSSML class]
                                     rootClass:[TTSNuanceTtsRoot class]
                                          file:TTSNuanceTtsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTSSSML__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "ssmlData",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t TTSSSML_SsmlValidationMode_RawValue(TTSSSML *message) {
  GPBDescriptor *descriptor = [TTSSSML descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TTSSSML_FieldNumber_SsmlValidationMode];
  return GPBGetMessageRawEnumField(message, field);
}

void SetTTSSSML_SsmlValidationMode_RawValue(TTSSSML *message, int32_t value) {
  GPBDescriptor *descriptor = [TTSSSML descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TTSSSML_FieldNumber_SsmlValidationMode];
  GPBSetMessageRawEnumField(message, field, value);
}

void TTSSSML_ClearSsmlDataOneOfCase(TTSSSML *message) {
  GPBDescriptor *descriptor = [TTSSSML descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - TTSTokenizedSequence

@implementation TTSTokenizedSequence

@dynamic tokensArray, tokensArray_Count;

typedef struct TTSTokenizedSequence__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *tokensArray;
} TTSTokenizedSequence__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tokensArray",
        .dataTypeSpecific.clazz = GPBObjCClass(TTSToken),
        .number = TTSTokenizedSequence_FieldNumber_TokensArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TTSTokenizedSequence__storage_, tokensArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTSTokenizedSequence class]
                                     rootClass:[TTSNuanceTtsRoot class]
                                          file:TTSNuanceTtsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTSTokenizedSequence__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTSToken

@implementation TTSToken

@dynamic tokenDataOneOfCase;
@dynamic text;
@dynamic controlCode;

typedef struct TTSToken__storage_ {
  uint32_t _has_storage_[2];
  NSString *text;
  TTSControlCode *controlCode;
} TTSToken__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "text",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSToken_FieldNumber_Text,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(TTSToken__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "controlCode",
        .dataTypeSpecific.clazz = GPBObjCClass(TTSControlCode),
        .number = TTSToken_FieldNumber_ControlCode,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(TTSToken__storage_, controlCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTSToken class]
                                     rootClass:[TTSNuanceTtsRoot class]
                                          file:TTSNuanceTtsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTSToken__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "tokenData",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void TTSToken_ClearTokenDataOneOfCase(TTSToken *message) {
  GPBDescriptor *descriptor = [TTSToken descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - TTSControlCode

@implementation TTSControlCode

@dynamic key;
@dynamic value;

typedef struct TTSControlCode__storage_ {
  uint32_t _has_storage_[1];
  NSString *key;
  NSString *value;
} TTSControlCode__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSControlCode_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TTSControlCode__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSControlCode_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TTSControlCode__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTSControlCode class]
                                     rootClass:[TTSNuanceTtsRoot class]
                                          file:TTSNuanceTtsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTSControlCode__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTSSynthesisResource

@implementation TTSSynthesisResource

@dynamic resourceDataOneOfCase;
@dynamic type;
@dynamic uri;
@dynamic body;

typedef struct TTSSynthesisResource__storage_ {
  uint32_t _has_storage_[2];
  TTSEnumResourceType type;
  NSString *uri;
  NSData *body;
} TTSSynthesisResource__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = TTSEnumResourceType_EnumDescriptor,
        .number = TTSSynthesisResource_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TTSSynthesisResource__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "uri",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSSynthesisResource_FieldNumber_Uri,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(TTSSynthesisResource__storage_, uri),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "body",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSSynthesisResource_FieldNumber_Body,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(TTSSynthesisResource__storage_, body),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTSSynthesisResource class]
                                     rootClass:[TTSNuanceTtsRoot class]
                                          file:TTSNuanceTtsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTSSynthesisResource__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "resourceData",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t TTSSynthesisResource_Type_RawValue(TTSSynthesisResource *message) {
  GPBDescriptor *descriptor = [TTSSynthesisResource descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TTSSynthesisResource_FieldNumber_Type];
  return GPBGetMessageRawEnumField(message, field);
}

void SetTTSSynthesisResource_Type_RawValue(TTSSynthesisResource *message, int32_t value) {
  GPBDescriptor *descriptor = [TTSSynthesisResource descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TTSSynthesisResource_FieldNumber_Type];
  GPBSetMessageRawEnumField(message, field, value);
}

void TTSSynthesisResource_ClearResourceDataOneOfCase(TTSSynthesisResource *message) {
  GPBDescriptor *descriptor = [TTSSynthesisResource descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - TTSLanguageIdentificationParameters

@implementation TTSLanguageIdentificationParameters

@dynamic disable;
@dynamic languagesArray, languagesArray_Count;
@dynamic alwaysUseHighestConfidence;

typedef struct TTSLanguageIdentificationParameters__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *languagesArray;
} TTSLanguageIdentificationParameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "disable",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSLanguageIdentificationParameters_FieldNumber_Disable,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "languagesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSLanguageIdentificationParameters_FieldNumber_LanguagesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TTSLanguageIdentificationParameters__storage_, languagesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "alwaysUseHighestConfidence",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSLanguageIdentificationParameters_FieldNumber_AlwaysUseHighestConfidence,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTSLanguageIdentificationParameters class]
                                     rootClass:[TTSNuanceTtsRoot class]
                                          file:TTSNuanceTtsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTSLanguageIdentificationParameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTSDownloadParameters

@implementation TTSDownloadParameters

@dynamic optionalDownloadParameterRequestTimeoutMsOneOfCase;
@dynamic headers, headers_Count;
@dynamic refuseCookies;
@dynamic requestTimeoutMs;

typedef struct TTSDownloadParameters__storage_ {
  uint32_t _has_storage_[2];
  uint32_t requestTimeoutMs;
  NSMutableDictionary *headers;
} TTSDownloadParameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "headers",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSDownloadParameters_FieldNumber_Headers,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TTSDownloadParameters__storage_, headers),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "refuseCookies",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSDownloadParameters_FieldNumber_RefuseCookies,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "requestTimeoutMs",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSDownloadParameters_FieldNumber_RequestTimeoutMs,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(TTSDownloadParameters__storage_, requestTimeoutMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTSDownloadParameters class]
                                     rootClass:[TTSNuanceTtsRoot class]
                                          file:TTSNuanceTtsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTSDownloadParameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "optionalDownloadParameterRequestTimeoutMs",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void TTSDownloadParameters_ClearOptionalDownloadParameterRequestTimeoutMsOneOfCase(TTSDownloadParameters *message) {
  GPBDescriptor *descriptor = [TTSDownloadParameters descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - TTSEventParameters

@implementation TTSEventParameters

@dynamic sendSentenceMarkerEvents;
@dynamic sendWordMarkerEvents;
@dynamic sendPhonemeMarkerEvents;
@dynamic sendBookmarkMarkerEvents;
@dynamic sendParagraphMarkerEvents;
@dynamic sendVisemes;
@dynamic sendLogEvents;
@dynamic suppressInput;

typedef struct TTSEventParameters__storage_ {
  uint32_t _has_storage_[1];
} TTSEventParameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sendSentenceMarkerEvents",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSEventParameters_FieldNumber_SendSentenceMarkerEvents,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "sendWordMarkerEvents",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSEventParameters_FieldNumber_SendWordMarkerEvents,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "sendPhonemeMarkerEvents",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSEventParameters_FieldNumber_SendPhonemeMarkerEvents,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "sendBookmarkMarkerEvents",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSEventParameters_FieldNumber_SendBookmarkMarkerEvents,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "sendParagraphMarkerEvents",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSEventParameters_FieldNumber_SendParagraphMarkerEvents,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "sendVisemes",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSEventParameters_FieldNumber_SendVisemes,
        .hasIndex = 10,
        .offset = 11,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "sendLogEvents",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSEventParameters_FieldNumber_SendLogEvents,
        .hasIndex = 12,
        .offset = 13,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "suppressInput",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSEventParameters_FieldNumber_SuppressInput,
        .hasIndex = 14,
        .offset = 15,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTSEventParameters class]
                                     rootClass:[TTSNuanceTtsRoot class]
                                          file:TTSNuanceTtsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTSEventParameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTSSynthesisResponse

@implementation TTSSynthesisResponse

@dynamic responseOneOfCase;
@dynamic status;
@dynamic events;
@dynamic audio;

typedef struct TTSSynthesisResponse__storage_ {
  uint32_t _has_storage_[2];
  TTSStatus *status;
  TTSEvents *events;
  NSData *audio;
} TTSSynthesisResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.clazz = GPBObjCClass(TTSStatus),
        .number = TTSSynthesisResponse_FieldNumber_Status,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(TTSSynthesisResponse__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "events",
        .dataTypeSpecific.clazz = GPBObjCClass(TTSEvents),
        .number = TTSSynthesisResponse_FieldNumber_Events,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(TTSSynthesisResponse__storage_, events),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "audio",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSSynthesisResponse_FieldNumber_Audio,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(TTSSynthesisResponse__storage_, audio),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTSSynthesisResponse class]
                                     rootClass:[TTSNuanceTtsRoot class]
                                          file:TTSNuanceTtsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTSSynthesisResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "response",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void TTSSynthesisResponse_ClearResponseOneOfCase(TTSSynthesisResponse *message) {
  GPBDescriptor *descriptor = [TTSSynthesisResponse descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - TTSUnarySynthesisResponse

@implementation TTSUnarySynthesisResponse

@dynamic hasStatus, status;
@dynamic hasEvents, events;
@dynamic audio;

typedef struct TTSUnarySynthesisResponse__storage_ {
  uint32_t _has_storage_[1];
  TTSStatus *status;
  TTSEvents *events;
  NSData *audio;
} TTSUnarySynthesisResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.clazz = GPBObjCClass(TTSStatus),
        .number = TTSUnarySynthesisResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TTSUnarySynthesisResponse__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "events",
        .dataTypeSpecific.clazz = GPBObjCClass(TTSEvents),
        .number = TTSUnarySynthesisResponse_FieldNumber_Events,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TTSUnarySynthesisResponse__storage_, events),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "audio",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSUnarySynthesisResponse_FieldNumber_Audio,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TTSUnarySynthesisResponse__storage_, audio),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTSUnarySynthesisResponse class]
                                     rootClass:[TTSNuanceTtsRoot class]
                                          file:TTSNuanceTtsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTSUnarySynthesisResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTSStatus

@implementation TTSStatus

@dynamic code;
@dynamic message;
@dynamic details;

typedef struct TTSStatus__storage_ {
  uint32_t _has_storage_[1];
  uint32_t code;
  NSString *message;
  NSString *details;
} TTSStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSStatus_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TTSStatus__storage_, code),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSStatus_FieldNumber_Message,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TTSStatus__storage_, message),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "details",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSStatus_FieldNumber_Details,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TTSStatus__storage_, details),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTSStatus class]
                                     rootClass:[TTSNuanceTtsRoot class]
                                          file:TTSNuanceTtsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTSStatus__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTSEvents

@implementation TTSEvents

@dynamic eventsArray, eventsArray_Count;

typedef struct TTSEvents__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *eventsArray;
} TTSEvents__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "eventsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(TTSEvent),
        .number = TTSEvents_FieldNumber_EventsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TTSEvents__storage_, eventsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTSEvents class]
                                     rootClass:[TTSNuanceTtsRoot class]
                                          file:TTSNuanceTtsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTSEvents__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTSEvent

@implementation TTSEvent

@dynamic name;
@dynamic values, values_Count;

typedef struct TTSEvent__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSMutableDictionary *values;
} TTSEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSEvent_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TTSEvent__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "values",
        .dataTypeSpecific.clazz = Nil,
        .number = TTSEvent_FieldNumber_Values,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TTSEvent__storage_, values),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTSEvent class]
                                     rootClass:[TTSNuanceTtsRoot class]
                                          file:TTSNuanceTtsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTSEvent__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
