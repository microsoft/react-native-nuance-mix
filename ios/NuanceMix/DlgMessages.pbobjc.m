// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dlg_messages.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "DlgMessages.pbobjc.h"
#import "NuanceAsr.pbobjc.h"
#import "NuanceAsrResult.pbobjc.h"
#import "NuanceTts.pbobjc.h"
#import "DlgCommonMessages.pbobjc.h"
#import "NuanceAsrResource.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(ASRAudioFormat);
GPBObjCClassDeclaration(ASRControlMessage);
GPBObjCClassDeclaration(ASRFormatting);
GPBObjCClassDeclaration(ASRRecognitionFlags);
GPBObjCClassDeclaration(ASRRecognitionResource);
GPBObjCClassDeclaration(ASRResult);
GPBObjCClassDeclaration(ASRStartOfSpeech);
GPBObjCClassDeclaration(ASRStatus);
GPBObjCClassDeclaration(DLGAsrParamsV1);
GPBObjCClassDeclaration(DLGExecuteRequest);
GPBObjCClassDeclaration(DLGExecuteRequestPayload);
GPBObjCClassDeclaration(DLGExecuteResponse);
GPBObjCClassDeclaration(DLGExecuteResponsePayload);
GPBObjCClassDeclaration(DLGSelector);
GPBObjCClassDeclaration(DLGStartRequest);
GPBObjCClassDeclaration(DLGStartRequestPayload);
GPBObjCClassDeclaration(DLGStartResponsePayload);
GPBObjCClassDeclaration(DLGTtsParamsV1);
GPBObjCClassDeclaration(DLGUpdateRequest);
GPBObjCClassDeclaration(DLGUpdateRequestPayload);
GPBObjCClassDeclaration(TTSAudioParameters);
GPBObjCClassDeclaration(TTSSynthesisResponse);
GPBObjCClassDeclaration(TTSVoice);

#pragma mark - DLGDlgMessagesRoot

@implementation DLGDlgMessagesRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - DLGDlgMessagesRoot_FileDescriptor

static GPBFileDescriptor *DLGDlgMessagesRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"nuance.dlg.v1"
                                                 objcPrefix:@"DLG"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - DLGStreamInput

@implementation DLGStreamInput

@dynamic asrControlOneofOneOfCase;
@dynamic ttsControlOneofOneOfCase;
@dynamic hasRequest, request;
@dynamic asrControlV1;
@dynamic audio;
@dynamic ttsControlV1;
@dynamic hasControlMessage, controlMessage;

typedef struct DLGStreamInput__storage_ {
  uint32_t _has_storage_[3];
  DLGExecuteRequest *request;
  DLGAsrParamsV1 *asrControlV1;
  NSData *audio;
  DLGTtsParamsV1 *ttsControlV1;
  ASRControlMessage *controlMessage;
} DLGStreamInput__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "request",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGExecuteRequest),
        .number = DLGStreamInput_FieldNumber_Request,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGStreamInput__storage_, request),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "asrControlV1",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGAsrParamsV1),
        .number = DLGStreamInput_FieldNumber_AsrControlV1,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DLGStreamInput__storage_, asrControlV1),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "audio",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGStreamInput_FieldNumber_Audio,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLGStreamInput__storage_, audio),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "ttsControlV1",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGTtsParamsV1),
        .number = DLGStreamInput_FieldNumber_TtsControlV1,
        .hasIndex = -2,
        .offset = (uint32_t)offsetof(DLGStreamInput__storage_, ttsControlV1),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "controlMessage",
        .dataTypeSpecific.clazz = GPBObjCClass(ASRControlMessage),
        .number = DLGStreamInput_FieldNumber_ControlMessage,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLGStreamInput__storage_, controlMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGStreamInput class]
                                     rootClass:[DLGDlgMessagesRoot class]
                                          file:DLGDlgMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGStreamInput__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "asrControlOneof",
      "ttsControlOneof",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void DLGStreamInput_ClearAsrControlOneofOneOfCase(DLGStreamInput *message) {
  GPBDescriptor *descriptor = [DLGStreamInput descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
void DLGStreamInput_ClearTtsControlOneofOneOfCase(DLGStreamInput *message) {
  GPBDescriptor *descriptor = [DLGStreamInput descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:1];
  GPBClearOneof(message, oneof);
}
#pragma mark - DLGStreamOutput

@implementation DLGStreamOutput

@dynamic hasResponse, response;
@dynamic hasAudio, audio;
@dynamic hasAsrResult, asrResult;
@dynamic hasAsrStatus, asrStatus;
@dynamic hasAsrStartOfSpeech, asrStartOfSpeech;

typedef struct DLGStreamOutput__storage_ {
  uint32_t _has_storage_[1];
  DLGExecuteResponse *response;
  TTSSynthesisResponse *audio;
  ASRResult *asrResult;
  ASRStatus *asrStatus;
  ASRStartOfSpeech *asrStartOfSpeech;
} DLGStreamOutput__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "response",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGExecuteResponse),
        .number = DLGStreamOutput_FieldNumber_Response,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGStreamOutput__storage_, response),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "audio",
        .dataTypeSpecific.clazz = GPBObjCClass(TTSSynthesisResponse),
        .number = DLGStreamOutput_FieldNumber_Audio,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLGStreamOutput__storage_, audio),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "asrResult",
        .dataTypeSpecific.clazz = GPBObjCClass(ASRResult),
        .number = DLGStreamOutput_FieldNumber_AsrResult,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLGStreamOutput__storage_, asrResult),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "asrStatus",
        .dataTypeSpecific.clazz = GPBObjCClass(ASRStatus),
        .number = DLGStreamOutput_FieldNumber_AsrStatus,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLGStreamOutput__storage_, asrStatus),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "asrStartOfSpeech",
        .dataTypeSpecific.clazz = GPBObjCClass(ASRStartOfSpeech),
        .number = DLGStreamOutput_FieldNumber_AsrStartOfSpeech,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DLGStreamOutput__storage_, asrStartOfSpeech),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGStreamOutput class]
                                     rootClass:[DLGDlgMessagesRoot class]
                                          file:DLGDlgMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGStreamOutput__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLGStartRequest

@implementation DLGStartRequest

@dynamic sessionId;
@dynamic hasSelector, selector;
@dynamic hasPayload, payload;
@dynamic sessionTimeoutSec;
@dynamic userId;
@dynamic clientData, clientData_Count;

typedef struct DLGStartRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t sessionTimeoutSec;
  NSString *sessionId;
  DLGSelector *selector;
  DLGStartRequestPayload *payload;
  NSString *userId;
  NSMutableDictionary *clientData;
} DLGStartRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sessionId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGStartRequest_FieldNumber_SessionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGStartRequest__storage_, sessionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "selector",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGSelector),
        .number = DLGStartRequest_FieldNumber_Selector,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLGStartRequest__storage_, selector),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "payload",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGStartRequestPayload),
        .number = DLGStartRequest_FieldNumber_Payload,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLGStartRequest__storage_, payload),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sessionTimeoutSec",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGStartRequest_FieldNumber_SessionTimeoutSec,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLGStartRequest__storage_, sessionTimeoutSec),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGStartRequest_FieldNumber_UserId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DLGStartRequest__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clientData",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGStartRequest_FieldNumber_ClientData,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLGStartRequest__storage_, clientData),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGStartRequest class]
                                     rootClass:[DLGDlgMessagesRoot class]
                                          file:DLGDlgMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGStartRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLGStartResponse

@implementation DLGStartResponse

@dynamic hasPayload, payload;

typedef struct DLGStartResponse__storage_ {
  uint32_t _has_storage_[1];
  DLGStartResponsePayload *payload;
} DLGStartResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "payload",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGStartResponsePayload),
        .number = DLGStartResponse_FieldNumber_Payload,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGStartResponse__storage_, payload),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGStartResponse class]
                                     rootClass:[DLGDlgMessagesRoot class]
                                          file:DLGDlgMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGStartResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLGUpdateRequest

@implementation DLGUpdateRequest

@dynamic sessionId;
@dynamic hasPayload, payload;
@dynamic clientData, clientData_Count;
@dynamic userId;

typedef struct DLGUpdateRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *sessionId;
  DLGUpdateRequestPayload *payload;
  NSMutableDictionary *clientData;
  NSString *userId;
} DLGUpdateRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sessionId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGUpdateRequest_FieldNumber_SessionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGUpdateRequest__storage_, sessionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "payload",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGUpdateRequestPayload),
        .number = DLGUpdateRequest_FieldNumber_Payload,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLGUpdateRequest__storage_, payload),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "clientData",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGUpdateRequest_FieldNumber_ClientData,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLGUpdateRequest__storage_, clientData),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGUpdateRequest_FieldNumber_UserId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLGUpdateRequest__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGUpdateRequest class]
                                     rootClass:[DLGDlgMessagesRoot class]
                                          file:DLGDlgMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGUpdateRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLGUpdateResponse

@implementation DLGUpdateResponse


typedef struct DLGUpdateResponse__storage_ {
  uint32_t _has_storage_[1];
} DLGUpdateResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGUpdateResponse class]
                                     rootClass:[DLGDlgMessagesRoot class]
                                          file:DLGDlgMessagesRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(DLGUpdateResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLGExecuteRequest

@implementation DLGExecuteRequest

@dynamic sessionId;
@dynamic hasSelector, selector;
@dynamic hasPayload, payload;
@dynamic userId;

typedef struct DLGExecuteRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *sessionId;
  DLGSelector *selector;
  DLGExecuteRequestPayload *payload;
  NSString *userId;
} DLGExecuteRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sessionId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGExecuteRequest_FieldNumber_SessionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGExecuteRequest__storage_, sessionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "selector",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGSelector),
        .number = DLGExecuteRequest_FieldNumber_Selector,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLGExecuteRequest__storage_, selector),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "payload",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGExecuteRequestPayload),
        .number = DLGExecuteRequest_FieldNumber_Payload,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLGExecuteRequest__storage_, payload),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGExecuteRequest_FieldNumber_UserId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLGExecuteRequest__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGExecuteRequest class]
                                     rootClass:[DLGDlgMessagesRoot class]
                                          file:DLGDlgMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGExecuteRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLGAsrParamsV1

@implementation DLGAsrParamsV1

@dynamic optionalSpeechDetectionSensitivityOneOfCase;
@dynamic hasAudioFormat, audioFormat;
@dynamic utteranceDetectionMode;
@dynamic hasRecognitionFlags, recognitionFlags;
@dynamic resultType;
@dynamic noInputTimeoutMs;
@dynamic recognitionTimeoutMs;
@dynamic utteranceEndSilenceMs;
@dynamic speechDetectionSensitivity;
@dynamic maxHypotheses;
@dynamic endStreamNoValidHypotheses;
@dynamic resourcesArray, resourcesArray_Count;
@dynamic speechDomain;
@dynamic hasFormatting, formatting;

typedef struct DLGAsrParamsV1__storage_ {
  uint32_t _has_storage_[2];
  ASREnumUtteranceDetectionMode utteranceDetectionMode;
  ASREnumResultType resultType;
  uint32_t noInputTimeoutMs;
  uint32_t recognitionTimeoutMs;
  uint32_t utteranceEndSilenceMs;
  float speechDetectionSensitivity;
  uint32_t maxHypotheses;
  ASRAudioFormat *audioFormat;
  ASRRecognitionFlags *recognitionFlags;
  NSMutableArray *resourcesArray;
  NSString *speechDomain;
  ASRFormatting *formatting;
} DLGAsrParamsV1__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "audioFormat",
        .dataTypeSpecific.clazz = GPBObjCClass(ASRAudioFormat),
        .number = DLGAsrParamsV1_FieldNumber_AudioFormat,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGAsrParamsV1__storage_, audioFormat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "utteranceDetectionMode",
        .dataTypeSpecific.enumDescFunc = ASREnumUtteranceDetectionMode_EnumDescriptor,
        .number = DLGAsrParamsV1_FieldNumber_UtteranceDetectionMode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLGAsrParamsV1__storage_, utteranceDetectionMode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "recognitionFlags",
        .dataTypeSpecific.clazz = GPBObjCClass(ASRRecognitionFlags),
        .number = DLGAsrParamsV1_FieldNumber_RecognitionFlags,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLGAsrParamsV1__storage_, recognitionFlags),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "resultType",
        .dataTypeSpecific.enumDescFunc = ASREnumResultType_EnumDescriptor,
        .number = DLGAsrParamsV1_FieldNumber_ResultType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DLGAsrParamsV1__storage_, resultType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "noInputTimeoutMs",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGAsrParamsV1_FieldNumber_NoInputTimeoutMs,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DLGAsrParamsV1__storage_, noInputTimeoutMs),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "recognitionTimeoutMs",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGAsrParamsV1_FieldNumber_RecognitionTimeoutMs,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DLGAsrParamsV1__storage_, recognitionTimeoutMs),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "utteranceEndSilenceMs",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGAsrParamsV1_FieldNumber_UtteranceEndSilenceMs,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(DLGAsrParamsV1__storage_, utteranceEndSilenceMs),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "speechDetectionSensitivity",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGAsrParamsV1_FieldNumber_SpeechDetectionSensitivity,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DLGAsrParamsV1__storage_, speechDetectionSensitivity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "maxHypotheses",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGAsrParamsV1_FieldNumber_MaxHypotheses,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(DLGAsrParamsV1__storage_, maxHypotheses),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "endStreamNoValidHypotheses",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGAsrParamsV1_FieldNumber_EndStreamNoValidHypotheses,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "resourcesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ASRRecognitionResource),
        .number = DLGAsrParamsV1_FieldNumber_ResourcesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLGAsrParamsV1__storage_, resourcesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "speechDomain",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGAsrParamsV1_FieldNumber_SpeechDomain,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(DLGAsrParamsV1__storage_, speechDomain),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "formatting",
        .dataTypeSpecific.clazz = GPBObjCClass(ASRFormatting),
        .number = DLGAsrParamsV1_FieldNumber_Formatting,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(DLGAsrParamsV1__storage_, formatting),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGAsrParamsV1 class]
                                     rootClass:[DLGDlgMessagesRoot class]
                                          file:DLGDlgMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGAsrParamsV1__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "optionalSpeechDetectionSensitivity",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t DLGAsrParamsV1_UtteranceDetectionMode_RawValue(DLGAsrParamsV1 *message) {
  GPBDescriptor *descriptor = [DLGAsrParamsV1 descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DLGAsrParamsV1_FieldNumber_UtteranceDetectionMode];
  return GPBGetMessageRawEnumField(message, field);
}

void SetDLGAsrParamsV1_UtteranceDetectionMode_RawValue(DLGAsrParamsV1 *message, int32_t value) {
  GPBDescriptor *descriptor = [DLGAsrParamsV1 descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DLGAsrParamsV1_FieldNumber_UtteranceDetectionMode];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t DLGAsrParamsV1_ResultType_RawValue(DLGAsrParamsV1 *message) {
  GPBDescriptor *descriptor = [DLGAsrParamsV1 descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DLGAsrParamsV1_FieldNumber_ResultType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetDLGAsrParamsV1_ResultType_RawValue(DLGAsrParamsV1 *message, int32_t value) {
  GPBDescriptor *descriptor = [DLGAsrParamsV1 descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DLGAsrParamsV1_FieldNumber_ResultType];
  GPBSetMessageRawEnumField(message, field, value);
}

void DLGAsrParamsV1_ClearOptionalSpeechDetectionSensitivityOneOfCase(DLGAsrParamsV1 *message) {
  GPBDescriptor *descriptor = [DLGAsrParamsV1 descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - DLGTtsParamsV1

@implementation DLGTtsParamsV1

@dynamic hasAudioParams, audioParams;
@dynamic hasVoice, voice;

typedef struct DLGTtsParamsV1__storage_ {
  uint32_t _has_storage_[1];
  TTSAudioParameters *audioParams;
  TTSVoice *voice;
} DLGTtsParamsV1__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "audioParams",
        .dataTypeSpecific.clazz = GPBObjCClass(TTSAudioParameters),
        .number = DLGTtsParamsV1_FieldNumber_AudioParams,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGTtsParamsV1__storage_, audioParams),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "voice",
        .dataTypeSpecific.clazz = GPBObjCClass(TTSVoice),
        .number = DLGTtsParamsV1_FieldNumber_Voice,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLGTtsParamsV1__storage_, voice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGTtsParamsV1 class]
                                     rootClass:[DLGDlgMessagesRoot class]
                                          file:DLGDlgMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGTtsParamsV1__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLGExecuteResponse

@implementation DLGExecuteResponse

@dynamic hasPayload, payload;

typedef struct DLGExecuteResponse__storage_ {
  uint32_t _has_storage_[1];
  DLGExecuteResponsePayload *payload;
} DLGExecuteResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "payload",
        .dataTypeSpecific.clazz = GPBObjCClass(DLGExecuteResponsePayload),
        .number = DLGExecuteResponse_FieldNumber_Payload,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGExecuteResponse__storage_, payload),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGExecuteResponse class]
                                     rootClass:[DLGDlgMessagesRoot class]
                                          file:DLGDlgMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGExecuteResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLGStopRequest

@implementation DLGStopRequest

@dynamic sessionId;
@dynamic userId;

typedef struct DLGStopRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *sessionId;
  NSString *userId;
} DLGStopRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sessionId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGStopRequest_FieldNumber_SessionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGStopRequest__storage_, sessionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGStopRequest_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLGStopRequest__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGStopRequest class]
                                     rootClass:[DLGDlgMessagesRoot class]
                                          file:DLGDlgMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGStopRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLGStopResponse

@implementation DLGStopResponse


typedef struct DLGStopResponse__storage_ {
  uint32_t _has_storage_[1];
} DLGStopResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGStopResponse class]
                                     rootClass:[DLGDlgMessagesRoot class]
                                          file:DLGDlgMessagesRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(DLGStopResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLGStatusRequest

@implementation DLGStatusRequest

@dynamic sessionId;

typedef struct DLGStatusRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *sessionId;
} DLGStatusRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sessionId",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGStatusRequest_FieldNumber_SessionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGStatusRequest__storage_, sessionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGStatusRequest class]
                                     rootClass:[DLGDlgMessagesRoot class]
                                          file:DLGDlgMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGStatusRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLGStatusResponse

@implementation DLGStatusResponse

@dynamic sessionRemainingSec;

typedef struct DLGStatusResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t sessionRemainingSec;
} DLGStatusResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sessionRemainingSec",
        .dataTypeSpecific.clazz = Nil,
        .number = DLGStatusResponse_FieldNumber_SessionRemainingSec,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLGStatusResponse__storage_, sessionRemainingSec),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLGStatusResponse class]
                                     rootClass:[DLGDlgMessagesRoot class]
                                          file:DLGDlgMessagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLGStatusResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
